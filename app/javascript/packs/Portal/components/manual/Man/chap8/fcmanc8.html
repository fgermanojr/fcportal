
<head>
<style type="text/css">
.inlinenote {
	font-size: small;
}
.style4 {
	text-indent: -0.7in;
	margin-left: 1.48in;
	margin-bottom: 0.08in;
}
.style5 {
	margin-left: 0.98in;
	margin-bottom: 0.08in;
}
.style6 {
	margin-left: 0.98in;
	margin-bottom: 0.08in;
}
.style10 {
	text-indent: -0.7in;
	margin-left: 0.98in;
	margin-bottom: 0.08in;
}
.style11 {
	font-weight: normal;
	margin-bottom: 0in;
}
.style12 {
	text-indent: -0.7in;
	font-weight: normal;
	margin-left: 0.98in;
	margin-bottom: 0.08in;
}
.style13 {
	font-weight: normal;
	text-indent: -0.7in;
	margin-left: 1.48in;
	margin-bottom: 0.08in;
}
.style15 {
	margin-left: 0.98in;
	margin-bottom: 0.08in;
}
.style16 {
	margin-bottom: 0.08in;
	font-weight: bold;
}
.style17 {
	border-style: solid;
	border-width: 1px;
}
</style>
</head>

<A NAME="GRAPHICS" ID="GRAPHICS"><H1>8. Graphics Subsystem </H1></A>
<P>

The FORTRAN CALCULUS graphics subsystem is a set of utilities which 
produce graphs in a two stage process, <I>synthesis</I> and <I>production</I>.</P>

<P>Graph synthesis is the creation and storage of graph information in a data base.  
The collection of information making up a graph is called a <I>graph object</I>, 
and it is referenced by name.  The synthesis process permits ordered information in several graphs to be assembled in a relatively random process concurrently, as it becomes available during computation. The resulting objects contain automatic programs for producing the graphs when they are retrieved by the production utilities. Graph production is the retrieval of graph objects followed by display on a monitor, printing on a graphics compatible printer, or plotting via a pen plotter.</P>

<P>The following utility command-calls are used for graph synthesis:</P>
<P><strong>@GRAFILE -</strong> Open Graph FIle Object in Database<br><strong>
@HEAD - </strong>Heading message in pixel coordinates</P>
<P><strong>@MESSAGE - Plot Message in pixel coordinates<br>@FONT - </strong>Font 
definition and rendering<br></P>
<P><strong>@AXLABS</strong> - Axis label definition<br><strong>@AXNAME -</strong> 
Axis name definition<br><strong>@AXSET -</strong> Axis System Element 
Suppression<br><strong>@AXTICKS -</strong> Modifying axis ticks<br><br><strong>
@XYGRAF -</strong> 
Definition of XY axes plot system&nbsp; [or is it XYPLOT&nbsp; CK]<br><B> @XAXIS</B> - Defines alternate horizontal axis<BR>

 <B> @YAXIS</B> - Defines alternate vertical axis<br><strong>@GRID - </strong>
Overlays a Grid on an Axix System<br><BR>

 <B> @SETUP </B>- Defines properties of a curve or point set<BR>
 <B> @CURVE </B>- Enters connected points on a curve function<BR>
 <B> @SPLINE </B>- Draws a cubic spline curve through the points of a function<BR>
 <B> @POINT </B>- Enters discrete (unconnnected) points in a point set&nbsp;&nbsp; 
[CK status]<br><strong>@NUMBER -</strong> Plot&nbsp; floating point number or integer at user 
coordinates<br>
<strong>@NUMPIX -</strong> Plot floating point number or integer at pixel coordinates<br><BR>
 <B> @CONTDEF </B>- Defines contour parameters for a set of contours<BR>
 <B> @MESH</B> - Generates a mesh grid of a contour function<BR>
 <B> @CONTOUR </B>- Generates contour curves for a group of contours<br>@<strong>POLAR</strong> 
- Plot a polar graph</P>

<P>The following utility command-calls are used for graph production:<BR>
 <B> @MODES </B>- Defines display modes for graphics &amp; text<BR>
 <B> @SHOW </B>- Displays a named graph on the graphics ... [FIX]<BR>
 <B> @DRAW</B> - Writes the named graph on a printer file (name.GPR)<BR>
 <B> @PLOT</B> - Plots a named graph on a pen plotter Graph Synthesis Command-Calls 
[CK status]<BR>
  <B>@CLEAR</B> - Deletes a graph object from the database</P>

<H2>8.1 Graph Synthesis Command Calls</H2>
<P><B><U> @YAXIS - Definition of y-axis<br></U></B><BR>

<B>Syntax:<br></B><BR>

  <B>@YAXIS(</B><I>name, yst, yin, ymajor, minor,label, ndec</i><B>)<br></B><BR>

<B>Symbols:<br></B><BR>

<I>name		</I>: character string 	=	 name of the graph <BR>


<I>yst</I>			: real*8 			=	value of y at the start of 
the y-axis <BR>

<I>yfin		</I>: real*8 			=	value of y at the end of the 
y-axis <BR>

<I>ymajor		</I>: real*8 			=	distance betrween major (large) 
tic marks on the <R>
													       y-axis <BR>

<I>minor		</I>: integer 			=	flag for use of minor tic 
marks (0,+1,-1) <BR>

<I>label</I>		: integer 			=	flag for auto-labeling of 
tic marks (0,+1) <BR>

<I>ndec</I>		: integer 			=	number of decimal places for 
auto-labeling (0,1,2,3)<br><BR>

This utility generates the y-axis element for the named graph. The 
@WINDOW and/or @FRAME utilities must be called before @YAXIS is called.</P>

<P>The major tic marks along the y-axis will be palced at intervals of 
<I>ymajor</I> starting at <I>yorg</I>.  If <I>ymajor</I> is positive/negative, 
then the tic marks will be placed to the right/left of the y-axis 
respectively. If <I>ymajor</I> is zero, then no tic marks are inserted.</P>

<P>If <I>minor</I>=0, then no minor tic marks are inserted.  If <I>minor</I>=+1, 
then minor tic marks are inserted halfway betreen the major tic marks 
(but are not labeled).  If <I>minor</I>=-1, then a logarithmic set 
of tic marks are inserted (for log plots).</P>

<P>If <I>label</I>=0, the there is no auto-labeling.  If <I>label</I>=1, 
the major tic marks are automatically supplied a label.  If<I> label</I>=-1, 
then the origin is labeled as well.  The format of the label is F10.n 
with the decimal point lined up with the major tic mark.  The label 
is on the opposite side of the y-axis from the tic marks. Here n=<I>ndec</I>=number 
of decimal points desired.  Note:  If the absolute value of y exceeds 
99999.999 at the tic mark then the label becomes 99999.999, except 
when <I>minor</I>=-1 (log axis), then the tic mark labels run from 
10.**<I>yst</I> ot 10.**<I>yfin</I> rather that from <I>yst</I> to 
<I>yfin</I>.</P>

<P>For a log axis, the values of <I>yst</I> and <I>yfin</I> should be 
one of the following:

  0.001, 0.01, 1.0, 10.0, 100.0, 1000.0 or 10000.0 

with <I>yst</I> less than <I>yfin</I>. </P>
<p class="style2"><strong>@AXLABS - Axis Label Definition</strong></p>
<p class="style2">Syntax:</p>
<p class="style4">@AXLABS(name,axis,typ,ornt,pos,just,ndig,ldst,klr)</p>
<p class="style2">Symbols : 
<p class="style6">name :
name of object and metafile (character string)</p>
<p class="style6">axis : axis or axes 
identifier (character string) (e.g 'XYZ')</p>
<p class="style6">typ : type of labels 
(character string)</p>
<p class="style6">'NONE' - suppress all 
labels</p>
<p class="style6">'FLOAT' - plot labels 
in floating point format</p>
<p class="style6">'EXP' - plot labels in 
exponential format where fractions range 1-10</p>
<p class="style6">'FEXP' - plot labels in 
fEn format where f range 1-10</p>
<p class="style6">'LOG' - plot 
logarithmic labels with base 10 and the corresponding exponents</p>
<p class="style6">'CLOG' - same as 'LOG' 
but label is centered below tick mark</p>
<p class="style6">'ELOG' - plot only the 
logarithmic values of labels</p>
<p class="style15">
'TIME' - plot time labels in <i>
hhmm </i>
format</p>
<p class="style15">
'HOURS' - plot time labels in <i>
hh</i> 
format</p>
<p class="style15">
'SECONDS' - plot time labels in <i>
hhmmss</i> 
format</p>
<p class="style6">'DATE' - plot date 
labels</p>
<p class="style6">'MAP' - plot geographic 
labels as positive floating point numbers with 'W','E','N','S' suffixes</p>
<p class="style6">'LMAP' - similar to 
'MAP' with lower case suffixes</p>
<p class="style6">'DMAP' - plots labels 
that are floating point numbers with degree symbols</p>
<p class="style6">'MYLAB' - plots labels 
defined with the routine MYLAB</p>
<p class="style6">ornt : orientation of 
labels (character string)</p>
<p class="style6">'HORI' - horizontal 
labels</p>
<p class="style6">'VERT' - vertical 
labels</p>
<p class="style6">pos : position of 
labels (character string)</p>
<p class="style6">'TICKS' - plot labels 
at major ticks</p>
<p class="style6">'CENTER' - plot labels 
centered between major ticks</p>
<p class="style6">'SHIFT' - shift 
starting and ending labels</p>
<p class="style6">just : justification of 
labels (character string)</p>
<p class="style6">'AUTO' - automatically 
justify labels</p>
<p class="style6">'LEFT' - left-justify 
labels</p>
<p class="style6">'RIGHT' - right-justify 
labels</p>
<p class="style6">'OUTW' - left-justify 
left and lower axis labels and right-justify right and upper axis labels</p>
<p class="style6">'INWA' - right-justify 
left and lower axis labels and left-justify right and upper axis labels</p>
<p class="style6">ndig : number of digits 
after decimal point in labels (integer)</p>
<p class="style6">-1 - integer labels</p>
<p class="style6">0 - integer with 
decimal point</p>
<p class="style6">n - number of digits 
after decimal point. The last digit will be rounded up</p>
<p class="style6">klr : color value of 
labels (integer) - see 8.3.3 Color Parameter</p>

<p class="style6">@AXNAME - Axis Name Definition</p>
<p class="style2">Syntax:</p>
<p class="style4">@AXNAME(name,axis,title,just,ndist,nhgt,klr)</p>
<p class="style2">Symbols:</p>
<p class="style15">name :
name of object and metafile</p>
<p class="style6">axis : axis or axes 
identifier (character string) (e.g 'XYZ')</p>
<p class="style6">title : axis title 
(character string, 60 characters or less).</p>
<p class="style6">just : align ment of 
axis title (character string): 'CENT', 'LEFT', or 'RIGHT'</p>
<p class="style6">ndist : (integer) 
distance in pixel coordinates between axis title and labels</p>
<p class="style6">nhgt : (integer) 
character height in pixel coordinates for axis names</p>
<p class="style6">klr : color value of 
labels (integer) - see 8.3.3 Color Parameters</p>
<h4>@AXSET - Axis System Element Suppression</h4>
<p class="style2">Syntax:</p>
<p class="style4">@AXSET(name,ax1,ay2,ax3,ay4)</p>
<p class="style2">Symbols:</p>
name
name of object and metafile<p class="style15">
ax1 : render lower x axis (character string): 
'NONE', 'LINE', 'TICKS', 'LABELS', or 'NAME'</p>
<p class="style15">
ay2 : render left y axis (character string): 
'NONE', 'LINE', 'TICKS', 'LABELS', or 'NAME'</p>
<p class="style15">
ax3 : render upper x axis (character string): 
'NONE', 'LINE', 'TICKS', 'LABELS', or 'NAME'</p>
<p class="style15">
ay4 : render right y axis (character string): 
'NONE', 'LINE', 'TICKS', 'LABELS', or 'NAME'</p>
<p class="style15">
With 'NONE', complete axis will be suppressed; 
with 'LINE', only axis lines will be plotted; with 'TICKS', axis lines and ticks 
will be plotted; with 'LABELS', axis lines, ticks, and labels will be plotted; 
and with 'NAME', all elements will be displayed.</p>

<h4>@AXTICKS - Modifying Axis Ticks</h4>
<p class="style2">Syntax:</p>
<p class="style4">@AXSET(name,axis,pos,maj,min,ntk,klr)</p>
<p class="style2">Symbols:</p>
<p class="style15">name
name of object and metafile</p>
<p class="style6">axis : axis or axes 
identifier (character string) (e.g 'XYZ')</p>
<p class="style6">pos : position of ticks 
(character string)</p>
<p class="style6">'LABELS' - plot ticks 
on the same size as labels</p>
<p class="style6">'CENTER' - center ticks 
on the axis line</p>
<p class="style6">'REVERS' - plot tick 
inside the axis system</p>
<p class="style6">maj : (integer) lengh 
of major ticks in pixel coordinates</p>
<p class="style6">min : (integer) lengh 
of minor ticks in pixel coordinates</p>
<p class="style6">ntk : (integer) number 
of ticks between axis labels</p>
<p class="style6">klr : color value of 
labels (integer) - see 8.3.3 Color Parameters</p>
<h4>
@CONTOUR - Generation of Contour Curves</h4>
Syntax:<br><br>@CONTOUR(name,id,values,lbflgs,kolors,lintyps,numcon)
<P>Symbols</P>
<P>name : name of object and metafile</P>
<P>id : (character*2) identifier of contour function
</P>
<P>values : (real) array of numcon contour values
</P>
<P>lbflgs : (integer) array of numcon contour flags (1 or 0) indicating whether a given contour should be labeled or unlabeled
</P>
<P>kolors : (integer) array of numcon color values (see 3.8.3 Color Parameters)
</P>
<P>lintyps : (integer) array of numcon line types (see 3.8.1 Line Type Parameters)
</P>
<P>numcon : (integer) number of contour curves <br></P>
<P>


<BR>

This utility generates as series of contours each corresponding to 
a fixed value of the contour function specified by <I>ident</I>.  The 
<I>values</I> array contains the <I>numcon</I> values to be assigned 
to the contours.  The <I>lbflg</I> array is a set of flags (1 or 0) 
indicating whether a given contour should be labeled (1) or unlabeled 
(0).</P>

<P>This utility is restricted to 10 contours per call.  For more contours 
on a given function, successive calls can be made with a different 
<I>values </I>array and numcon.  However, all labeled contours must 
be in the first call.  In successive calls, the <I>lbflg</I> array 
should be set to zero.  Also, <I>idef</I> must be set to 1 or 2 to 
avoid having the prior contours cleared during successive calls.</P>

<P>The <I>idef</I> parameter controls the use of default properties.  If 
<I>idef</I>=0, the default plot size, graphics mode, contour line 
colors and legend are used.  If <I>idef</I>=1, the plot size is set 
by default and the line colors and legend are defined by @CONTDEF, 
which must precede the call to @CONTOUR for the associated <I>ident</I>.  If 
<I>idef</I>=2, the line colors and legend are defined by the @CONTDEF, 
but the plot window must be defined by a preceding call to @WINDOW.  In 
the latter cases (<I>idef</I>=1,2), graphics mode must be set by @MODES 
before the graph is produced by @SHOW or @DRAW. <br> </P>
<h4>@NUMBER - Plot Floating Point Number or Integer at 
User Coordinates</h4>
<p class="style2">Syntax:<br><br>@NUMBER(name,val,ndig,xp,yp,nh,ndeg,klr)</p>
<p class="style2">Symbols:</p>
<p class="style10">name
name of object and metafile</p>
<p class="style10">
val : (real) number value</p>
<p class="style10">
ndig : (integer) number of digits after 
decimal point</p>
<p class="style10">
xp : (real) user x-coordinate of upper left 
corner</p>
<p class="style10">
yp : (real) user y-coordinate of upper left 
corner</p>
<p class="style10">
nh : (integer) character height in pixels</p>
<p class="style10">
ndeg : (integer) angle in degrees 
(counter-clockwize)</p>
<p class="style10">
klr : (integer) color parameter - see 8.3.3 
Color Parameters</p>
<p class="style2">Note:</p>
<p class="style15">
To continue character strings and numbers on 
the same line, the coordinates (999,999) should be sent to MESSAGE and NUMBER. 
The text or numbers will be plotted after the last plotted text character or 
number.</p>
<P> <BR>

<B><U> @SETUP - Properties of curves and point sets<br></U></b><BR>

<B>Syntax:<br></B><BR>

 <B> @SETUP(</b><I>name, ident,Ltype, 
Kolor, Symbol, Ksym</i><B>)<br></B><BR>

<B>Symbols:<br></B><BR>

<I>name		</I>: character*8	=	name of graph <BR>

<I>ident		</I>: character*2	=	identifier of function <BR>

Ltype : integer = line type (see 8.3.1: Line Type Parameters)<BR>

K<I>olor</I> : integer = color of curve (see 8.3.3 Color Parameters)<BR>

S<I>ymbol		</I>: integer = plot symbol for curve (see 8.3.2 Symbol Type 
Parameters)<BR>

K<I>sym		</I>: integer = symbol frequency (1=every point, 2= every other 
point, etc.)<br><BR>

This utility sets up the properties of graph functions to be generated 
by the @CURVE, @POINT, or @SPLINE utilities.  Each function in the graph must 
have a unique 2-character identifier ident. Each function in the graph must have 
a unique 2-character identifier ident.</P>

<P>If <I>ndots</I>=0 then a solid line is drawn.  If<I> ndots</I>=1 then 
no line is drawn.  For <I>ndots</I> greater than 1, dashed lines are 
drawn with the dashes having <I>ndots</I> pixels.  The color of the 
solid or dashed line is specified by the <I>kolor</I> index.</P>

<P>If <I>symbol</I>=-1, then the default (cross) is drawn at the data 
points generated by @CURVE or @POINT.  If <I>symbol</I>=-2 then no 
symbol is drawn.  Otherwise the character with ASCII index symbol 
is drawn.  If a symbol is drawn, then its color is given by the <I>klrsym</I> 
index.<BR></P>

<B><U> <br>@CURVE - Connected points on a curve function<br></U></b><BR>

<B>Syntax:<br></B><BR>

<B>@CURVE(</B><I>name,id, xpoint, ypoint</i><b>)&nbsp;&nbsp;<br></B><BR>

<B>Symbols:<br></B><BR>

<I>name		</I>: character*8 		=	name of graph <BR>

<I>id		</I>: character*2 		=	identifier of curve function<BR>

X<I>point		</I>: real*8 			=	abscissa value of a point <BR>


Y<I>point</I>		: real*8 			=	ordinate value of a point<br><BR>

This utility is called repeatedly to enter points of a function into 
the graph object.  These points are tabulated sequentially in a table 
file of the object identified by <I>ident</I>. When the graph is finally 
produced from the object (via @SHOW or @DRAW), the resulting table (all of the 
points together) will be plotted in the order in which the first point is 
tabulated in the sequence of the elements of the graph. Thus, although the 
tabulation of points is intermittant, and may be interleaved with the tabulation 
of the points of other functions, each table is separate, and when the graph is 
produced, each table is plotted contiguously in the order in which the first 
point of each table was tabulated in the graph object. In this case, <em>only 
the points are plotted, and symbols must have been selected</em> via @SETUP for 
these points to appear.<BR>

<U> <br><b>@SPLINE - Cubic spline interpolation of a curve function<br></b></U><BR>

<B>Syntax:<br></B><BR>

 <B> @SPLINE(</b><I>name,ident, xpoint,ypoint</i><B>)<br></B><BR>

<B>Symbols:<br></B><BR>

<I>name</I>		: character*8 		=	name of graph <BR>

<I>ident</I>		: character*2 		=	identifier of curve function <BR>


<I>xpoint</I>		: real*8 			=	 abscissa value of a point <BR>


<I>ypoint</I>		: real*8 			=	 ordinate value of a point<br><BR>

This utility is called repeatedly to enter points of a function into 
the graph object.  These points are tabulated sequentially in a table 
file of the object identified by ident.  When the graph is finally 
produced from the object (via @SHOW or @DRAW), the resulting table 
(all of the points together) will be plotted in the order in which 
the first point is tabulated in the sequence of the elements of the 
graph.  Thus, although the tabulation of points is intermittant, and 
may be interleaved with the tabulation of the points of other functions, 
each table is separate, and when the graph is produced, each table 
is plotted contiguously in the order in which the first point of each 
table was tabulated in the graph object.  In this case the resulting 
curve in between the tabulated points is filled in by interpolating 
a cubic spline fit of the tabulated points, resulting in a smooth 
curve that passes through all of the points.  The curve will have 
the dashed properties, color, and symbol annotation defined for the 
corresponding ident by @SETUP. 
<BR>
<b><U> <br>@POINT - Discrete (unconnected) points on a curve function<br></U></B><BR>

<B>Syntax:<br></B><BR>

 <B> @POINT(</b><I>name, ident, xpoint,ypoint</i><B>)<br></B><BR>

<B>Symbols:<br></B><BR>

<I>name		</I>: character*8 		=	name of graph <BR>

<I>ident</I>		: character*2 		=	identifier of curve function <BR>


<I>xpoint		</I>: real*8 			=	abscissa value of a point <BR>


<I>ypoint		</I>: real*8 			=	ordinate value of a point<br><BR>

This utility is called repeatedly to enter points of a function into 
the graph object.  These points are tabulated sequentially in a table 
file of the object identified by ident.  When the graph is finally 
produced from the object (via @SHOW or @DRAW), the resulting table 
(all of the points together) will be plotted in the order in which 
the first point is tabulated in the sequence of the elements of the 
graph.  Thus, although the tabulation of points is intermittant, and 
may be interleaved with the tabulation of the points of other functions, 
each table is separate, and when the graph is produced, each table 
is plotted contiguously in the order in which the first point of each 
table was tabulated in the graph object.  In this case only the points 
are plotted, and symbols must have been selected via @SETUP for these 
points to appear.<h4></h4>
<strong>@NUMPIX - Plot Floating Point Number or Integer at 
Pixel Coordinates</strong><br><br>Syntax:<br><br>@NUMPIX(name,val,ndig,nx,ny,nh,ndeg,klr)<br><br>Symbols:
<br><br>name
name of object and metafile
<br>nx : (integer) user x-pixel coordinate of 
upper left corner
<br>ny : (integer) user y-pixel coordinate of 
upper left corner
<br>nh : (integer) character height in pixels
ndeg : (integer) angle in degrees 
(counter-clockwize)

<br>klr : (integer) color parameter - see 8.3.3 
Color Parameters

<br><br>To continue character strings and numbers on 
the same line, the coordinates (999,999) should be sent to MESSAGE and NUMBER. 
The text or numbers will be plotted after the last plotted text character or 
number.

<h4>
<b><U>@CONTDEF - Definition of contour parameters for set 
of contours</u></b></h4>
Syntax:<br><BR>

<B>@CONTDEF(</B><I>name, ident,lcolor, ucolor, mcolor, legend</I>)<br><BR>

<B>Symbols:<br></B><BR>

<I>name		</I>: character*8 	= 	name of graph <BR>

<I>ident</I>		: character*2 	= 	identifier of contour 
function<BR>

<I>lcolor</I>		: integer 		= 	color index of labeled contours <BR>


<I>ucolor</I>		: integer 		= 	color index of unlabeled 
contours <BR>

<I>mcolor</I>		: integer 		= 	color index of marker labels 
on labeled contours <BR>

<I>legend</I>		: integer 		= 	legend flag<br><BR>

This utility performs the setup function for a contour function. It 
must be called prior to @CONTOUR.  If <I>legend</I>=0, then no legend 
is produced by @CONTOUR, otherwise a legend will be produced.<BR>

<b>

<U><br>@MESH - Contour function mesh generation<br></U></B><BR>

<B>Syntax:<br></B><BR>

 <B> @MESH(</b><I>name, ident, xmin, xmax, ymin,ymax, nx, ny, cfun</i><B>)<br></B><BR>

<B>Symbols:<br></B><BR>

<I>name</I>		: character*8 	=	name of graph <BR>

<I>ident		</I>: character*2 	=	identifier of contour function <BR>


<I>xmin		</I>: real*8 		=	minimum value of x-coordinate <BR>


<I>xmax</I>		: real*8 		=	maximum value of x-coordinate <BR>


<I>ymin		</I>: real*8 		=	minimum value of y-coordinate <BR>


<I>ymax</I>		: real*8 		=	maximum value of y-coordinate <BR>


<I>nx			</I>: integer 		=	mesh size in x-direction <BR>

<I>ny			</I>: integer 		=	mesh size in y-direction <BR>

<I>cfun		</I>: real*4 		=	external FUNCTION subprogram 
defining contour function<BR>

<br>This utility must be called prior to @CONTOUR. It generates a 2-dimensional 
table of the contour function by calling the external function subprogram 
once for each mesh point in the table.  This table is written to a 
file of the graph object which is subsequently used in producing the 
contour plot via one or more calls to @CONTOUR.<br><BR>

<U></b>@CONTOUR - Generation of contour curves</U></B><BR><BR>

<B>Syntax:<br></B><BR>

 <B> @CONTOUR</b>(<I>name,ident, xscale, values, lbflg, numcon, idef</i><B>)<br></B><BR>

<B>Symbols:<br></B><BR>

<I>name</I>		: character*8	=	name of graph<BR>

<I>ident</I>		: character*2	=	identifier of contour function <BR>


<I>xscale</I>		: real*8 		= 	aspect ratio of CRT<BR>

<I>values</I>		: real*8 		= 	array of <I>numcon</I> contour 
values <BR>

<I>lbflg</I>		: integer 		= 	array of <I>numcon</I> contour 
flags <BR>

<I>numcon</I>	: integer 		= 	number of contour curves 
(1-10) <BR>

<I>idef</I>		: integer 		= 	plot size parameter
<P> <br> </P>

@FONT - Font Definition and Rendering <br>
<br>Syntax:
<br>
<br>&nbsp;@FONT(name,fname,basalf,csize,klr)
<br>
<br>Symbols:
<br>
<br>
name :of object and metafile
<br>fname : font name (character string) can have the values 
'<a HREF="http://www.mps.mpg.de/dislin/complx.html">COMPLEX</a>',
'<a HREF="http://www.mps.mpg.de/dislin/simplx.html">SIMPLEX</a>', 
and 
'<a HREF="http://www.mps.mpg.de/dislin/helve.html">HELVE</a>'
<br>basalf: basic alphabet (character string), can have the values 'STANDARD', 'ITALIC', 'GREEK', 'SCRIPT', 'RUSSIAN', AND 'MATHEMATIC'
csize : (integer) character height in pixel coordinates
klr : color value of labels (integer) - see 8.8.3 Color Parameters

8.3.3 Color ParametersEND ==NEW==<br><br>

<h4>@GRAFIL - Open Graph File Object in Database</h4>
<p class="style2">Syntax:</p>
<p class="style4">@GRAFIL(name,type,page,width,height)</p>
<p class="style2">
Symbols:</p>
<p class="style15"><b>name </b>
: name of object and metafile (character 
string)</p>
<p class="style15"><b>type </b>
: metafile type (character string)</p>
<p class="style11" style="page-break-before: auto;">'SUM' - PNG graph in Summary 
Report Stream</p>
<p class="style11" STYLE="page-break-before: auto;">'DET' - PNG graph Detail 
Report Stream</p>
<p class="style15">page : 
predefined page size codes for print device 
(character string)</p>
<p class="style6">' ' - Not used 
(default)</p>
<p class="style6">'SC2Q' - 1/3 page size 
(scale factor = 0.5)</p>
<p class="style6">'SC3Q' - 1 /2 page size 
(scale factor = 0.75)</p>
<p class="style6">'SC5Q' - 5/6 page size 
(scale factor = 1.25)</p>
<p class="style6">'SC6Q' - full page size 
(scale factor = 1.5)</p>
<p class="style6">'PX2Q' - 1/3 page size 
(427x302 pixels)</p>
<p class="style6">'PX3Q' - 1 /2 page size 
(640x453 pixels)</p>
<p class="style6">'PX5Q' - 5/6 page size 
(1066x754 pixels)</p>
<p class="style6">'PX6Q' - full page size 
(1280x905 pixels)<br></p>
<p class="style15"><b>width </b>
: integer width of image in pixels</p>
<p class="style15"><b>height </b>
: integer height in pixels</p>
<p class="style2">
Action:</p>
<p class="style15">
Creates object <i>
name</i> 
in graphics database</p>
<p class="style5">
Writes
<i>name</i>.OBG 
metafile.
<h4>@GRID - Overlays a Grid on an Axis System</h4>
<p class="style2">Syntax:</p>
<p class="style4">@GRID(name,nx,ny)</p>
<p class="style2">Symbols:</p>
<p class="style15">name
name of object and metafile</p>
<p class="style15">
nx : (integer) number of grid lines between 
labels on x-axis</p>
<p class="style10">
ny : (integer) number of grid lines between 
labels on y-axis</p>
<h4 CLASS="western">@HEAD - Heading Message in pixel coordinates</h4>
<p class="style2">Syntax:</p>
<p class="style4">@HEAD(name,heading,nx,ny,klr)</p>
<p class="style2">Symbols:</p>
<p class="style10">
name : name of object and metafile</p>
<p class="style10">
heading : message (character string)</p>
<p class="style10">
nx : (integer) x-plot coordinate of upper left 
corner of heading message</p>
<p class="style10">
ny : (integer) y-plot coordinate of upper left 
corner of heading message</p>
<p class="style12">
klr : color value of message (integer) - see 
8.3.3 Color Parameters<br><br></p>
<h4>@MESSAGE - Plot Message in pixel coordinates</h4>
<p class="style2">Syntax:</p>
<p class="style4">@MESSAGE(name,message,xm,ym,klr)</p>
<p class="style2">Symbols:</p>
<p class="style10">name
name of object and metafile</p>
<p class="style10">
message : message (character string)</p>
<p class="style10">
xm : (real) user x-coordinate of upper left 
corner of message</p>
<p class="style10">
xm : (real) user y-coordinate of upper left 
corner of message</p>
<p class="style12">
klr : color value of message (integer) - see 
8.3.3 Color Parameters</p>
<p class="style2">Note:</p>
<h4>@POLAR - Plot a Polar Grid</h4>
<p class="style2">Syntax:</p>
<p class="style4">@POLAR(name,ncirc,nsect)</p>
<p class="style2">Symbols:</p>
<p class="style10">name
name of object and metafile</p>
<p class="style10">
ncirc : (integer) number of circles between 
labels</p>
<p class="style10">
nsect : (integer) number of sectors 
between labels</p>
<h4>@XAXIS - Plot an Alternative X Axis</h4>
<p class="style16">Syntax:</p>
<p class="style13">@XAXIS(name, xst, xfin, xorg, xstep, length, label, it, nx, 
ny)</p>
<p class="style16">Symbols:</p>
<p class="style15">name
name of object and metafile</p>
<p class="style15"><b>xst</b> 
: start value of x coordinate</p>
<p class="style15"><b>xfin</b> 
: final value of x coordinate</p>
<p class="style15"><b>xorg</b> 
: first label of x coordinate</p>
<p class="style15"><b>xstep</b> 
: step between labels</p>
<p class="style15"><b>length</b> 
: length of axis in pixel coordinates</p>
<p class="style15"><b>label</b> 
: character string containing axis name</p>
<p class="style15"><b>it </b>
: integer indicating how ticks, labels, and 
axis name are plotted</p>
<p class="style6">it = 0 : clockwise 
direction</p>
<p class="style6">it = 1 : 
counter-clockwise direction</p>
<p class="style15"><b>nx </b>
: integer X plot coordinate of axis starting 
point (plotted from left to right)</p>
<p class="style15"><b>ny </b>
: integer Y plot coordinate of axis starting 
point</p>
<h4><br><br></h4>
<h4>@XYGRAF -</h4>
<h4>@XYPLOT - Definition of XY Axes Plot System</h4>
<p class="style16">Syntax:</p>
<p class="style13">
@XYPLOT(name,axty,xmin,xmax,xorg,xstep,ymin,ymax,yorg,ystep,sfac,linlogx,linlogy,nxticks,nyticks)</p>
<p class="style16">Symbols:</p>
<p class="style15">name
name of object and metafile (character string)</p>
<p class="style6">axty : axes type 
(character string)</p>
<p class="style6">'RECT' - rectangular 
box of dual axes (origin in lower left corner)</p>
<p class="style6">'CROSS' - single 
crossed axes (origin in center)</p>
<p class="style6">xmin : lower limit of 
x-axis (real)</p>
<p class="style6">xmax : upper limit of 
x-axis (real)</p>
<p class="style6">xorg : first x-axis 
label value (real)</p>
<p class="style6">xstep : x-step between 
labels (real)</p>
<p class="style6">ymin : lower limit of 
y-axis (real)</p>
<p class="style6">ymax : upper limit of 
y-axis (real)</p>
<p class="style6">yorg : first y-axis 
label value (real)</p>
<p class="style6">ystep : y-step between 
labels (real)</p>
<p class="style6">sfac : scale facter 
(not used at present (replaced in GRAFIL)</p>
<h4>@YAXIS - Plot an Alternative Y Axis</h4>
<p class="style16">Syntax:</p>
<p class="style13">@YAXIS(name, yst, yfin, yorg, ystep, length, label, it, nx, 
ny)</p>
<p class="style16">Symbols:</p>
<p class="style15"><b>name </b>
: name of object and metafile</p>
<p class="style15"><b>yst</b> 
: start value of y coordinate</p>
<p class="style15"><b>yfin</b> 
: final value of y coordinate</p>
<p class="style15"><b>yorg</b> 
: first label of y coordinate</p>
<p class="style15"><b>ystep</b> 
: step between labels</p>
<p class="style15"><b>length</b> 
: length of axis in pixel coordinates</p>
<p class="style15"><b>label</b> 
: character string containing axis name</p>
<p class="style15"><b>it</b> 
: integer indicating how ticks, labels, and axis name are plotted</p>
<p class="style6">it = 0 : clockwise 
direction</p>
<p class="style6">it = 1 : 
counter-clockwise direction</p>
<p class="style15"><b>nx</b> 
: integer X plot coordinate of axis starting point (plotted from bottom to top)</p>
<p class="style10"><b>ny</b> 
: integer Y plot coordinate of axis starting point</p>
<p class="style10">
This utility produces a graph image from the 
named graph object. </p>
<H2>8.2 Graph Production Command Calls</H2>

<B><U> @SHOW - Graph display<br></U></B><BR>

<B>Syntax:<br></B><BR>

 <B> @SHOW(</B><I>name</i><B>)<br></B><BR>

<B>Symbols:<br></B><BR>

 <I>name</I>: character*8 - name of graph<br><BR>

This utility causes the graph to be displayed on the console monitor.  This 
display will remain on the monitor until the enter key is pressed, 
allowing the program to continue.<br><BR>

<B><U> @DRAW - Write graph print file<br></U></B><BR>

<B>Syntax:  <br>  </B><BR>

  @<B>DRAW(</B><I>name</i><B>)<br></B><BR>

<B>Symbols:<br></B><BR>

<I>name</I>	:	character*8 		= name of graph<br><BR>

This utility writes the named graph to a print file of the same name 
with file extension ".GPR".  This file is closed. <BR>

<b><U> <br>@CLEAR - Delete graph object from database<br></U></B><BR>

<B>Syntax:<br></B><BR>

 <B>@CLEAR(</b><I>name</i><B>)</B><BR>
<BR>
<B>Symbol:<br></B><BR>

<I>name</I>	: 	character*8		= name of graph<br><BR>

This utility removes the named graph object from the database to free 
space for additional objects.  It is applied after a graph has been 
produced, deleting the synthesis files used in the production.  Thus 
it does not affect output of graphs that have already been produced.
<H2>8.3 X-Y Plotting Applications</H2>

<P>In view of the economy of problem expression provided by calculus-level 
macro statements, graphics commands for those programs employing graphics 
tend to dominate problem coding. Moreover, since this chapter on graphics 
follows all of the chapters dealing with the calculus operations, 
it is convenient to present applications problems here that utilize 
combinations of features, including graphics.  In the following discussions, 
these applications are presented in their entirety and topically discussed 
with emphasis on usage of the graphics operations, but with also some 
discussion regarding the calculus operations used in the applications.<br><BR>

<B><U>   Applications Problem 8-1: Admittance Circuit Fit</U></B>

<P>This application was introduced as illustration problem 3 in Section 
2.1, which gives a circuit diagram and a discussion of the model.  The 
graphics-enhanced version of this program is given below.</P>

<P>In the problem procedure, two command-calls to the procedures AXES 
and FINISH serve to setup graph synthesis for the program and to produce 
the final graph image respectively.</P>
<P>[problem circuit][procedure axis]&nbsp;</P> 

<P><B>AXES Procedure</B> - This procedure creates the graph object with 
the command @GRAPH.  It establishes the absolute character size at 
0.2 inches for printing on a 300 DPI laser printer, and defines a 
5 inch by 4 inch frame in the lower-left corner of the printer's raster 
(in order to make the graphics capture file small enough to easily 
import into Ventura publisher).  The plotting window of the graph 
is then generated via the @WINDOW command.  This establishes the scaling 
for the subsequent functions to be plotted.</P>

<P>The subsequent @SETUP commands create the identity of the three functions 
to be plotted:<BR>

<UL>
<LI>'Y ' - The discrete data points of the measurements represented 
by yellow asterisks;</LI>

<LI>'Y0' - The green curve of the admittance function based 
on the initial guess of its parameters; and</LI>

<LI>'YC' - The red curve of the admittance function based on 
the final convergence values of the parameters.</LI>
</UL>

<P>These identifiers are later used as sort keys to sort the data entered 
into the graph object via @POINT and @CURVE commands, so that the 
separate functions are accumulated individually even though the functions 
are generated concurrently.</P>

<P>The subsequent commands @XAXIS, @YAXIS, @XELABEL, and @YELABEL establish 
and label the two coordinate axes.</P>

<P>Next, the two initially known functions (data points and the admittance 
function based upon guessed parameters) are generated and entered 
into the database.</P>

<P>Finally, labels are placed in the graph in proximity to the functions 
they describe.</P>

<P><B>FINISH procedure</B> - The FINISH procedure is used to generate 
the 'YC' (converged) version of the admittance function in the graph 
to show goodness of fit.  The DO loop computes the YC function and 
uses @CURVE enter it into the graph object of the database.</P>

<P><B>Graph Production</B> - Up to this point all graphics operations 
have been part of the synthesis phase which accumulates the graph 
object in the database.  The production of a graphical image from 
this object is accomplished via the @SHOW command (for screen display) 
or the @DRAW command (for print file generation). However, the particular 
form of graphics production is also governed by the GRAPHICS metacommand 
which precedes the PROBLEM statement.  When this command is present, 
it overrides the type of the production command, causing output to 
be routed to the "SCREEN", "FILE", or "BOTH".  In this application, 
the graph image was routed to "BOTH" screen and print file.  The resulting 
screen and print images are shown in Figures 8-1 and 8-2.<br>
<P><BR>
[FIG 8-1] [fig 8-2]<br><br>

<B><U>   Application Problem 8-2: Pilot Ejection Profile</U></B><BR>

<P>This problem has been used for many years as an example to demonstrate 
continuous simulation languages using a trial &amp; error trajectory simulation 
to characterize safe ejection in a piecemeal fashion.  This version 
is somewhat different, in that the whole problem of profiling the 
regime of safe ejection is completed in one run using implicit equations 
solver AJAX to solve a series of two-point boundary value problems.
<br><br><pre>
      GLOBAL ALL
      !  &amp;DEBUG pull
      PROBLEM EJECT !        PILOT EJECTION PROFILE
      !----------------------------------------------------------------|
      ! Traditional trial-and-error simulation model from 1970 CSSL    |
      ! Specification. Solved as a repeated two-point boundary-value   |
      ! problem to produce an altitude-velocity safe-ejection profile  |
      ! in closed form using Fortran Calculus. It employs integration  | 
      ! solver ISIS nested within Newton solver AJAX, with trajectory  |
      ! iterations displayed via web graphics.                         |
      !----------------------------------------------------------------|
        DIMENSION ALT(6),VEL(6)
        CHARACTER FCSINT*2,PLANE*7,TOCENTRY*50,TOCLABEL*50
        DATA ALT/0,10000,20000,30000,40000,50000/     !  Altitude table
        SMASS=7: G=32.2: CD=1: VE=40: THETAD=15: TIME=1.0
        S=10: Y1=4: VA=100
        DO 10 I=1,6
          H=ALT(I) : IT=0 : PLANE='PLANE'//FCSINT(I)
          @AXES(PLANE,'PILOT EJECTION')
          IF(H.LE.35332) THEN   ! Atmospheric density model
             RHO=0.002378*(1-.689E-5*H)**4.256
          ELSE
             RHO=0.00315/EXP(1.452+(H-35332)/20950)
          ENDIF
          !----------------- MetaCalculus Statement ------------------
          FIND VA,TIME; IN SEAT(PLANE); BY AJAX(ACON); TO MATCH GX,GY
          !----------------------------------------------------------- 
          TOCENTRY=TOCLABEL('TRAJECTORY ITERATIONS AT ALTITUDE=',H)
          @DISPLAY(PLANE,TOCENTRY)
          VEL(I)=VA
   10   CONTINUE
        @SAFE('PROFILE')
      END
      !   &amp;NODEBUG pull
      CONTROLLER ACON(AJAX) ! FIND control parameters for Ajax solver
        DAMP=0    ! Suppress damping in damped Newton method
        SUMOUT=1  ! Send iteration summary report to SUMMARY stream
        DETAIL=1  ! Create iteration detail report for each iteration
        DETOUT=-1 ! Send iteration report to DETAIL stream  
      END

      !------------- Simulation Model of Seat Trajectory -------------|
      MODEL SEAT(AIRPLANE)
        CHARACTER*2 FCSINT,NI,AIRPLANE*7
        VX=SQRT(VA**2)-VE*SIND(THETAD) : VY=VE*COSD(THETAD)
        V=SQRT(VX*VX+VY*VY) : THETA=ATAN(VY/VX)
        X=0 : Y=Y1 : T=0 : DT=ABS(TIME)/20 : DP=4*DT : TP=T+DP
        IT=IT+1 : NI=FCSINT(IT)  
        IF(IT.GT.9) THEN
            @POINT(AIRPLANE,'I'//NI,X,Y)       
        ELSE
            @CURVE(AIRPLANE,'I'//NI,X,Y)
        ENDIF
        !------------------ MetaCalculus Statement ------------------
        INITIATE ISIS; FOR MOTION; EQUATIONS
     &amp;     THEDOT/THETA, VDOT/V, XDOT/X, YDOT/Y; OF T; STEP DT; TO TP
        !------------------------------------------------------------
        DO WHILE (T.LT.TIME)
          !--MetaCalculus Statemant--
          INTEGRATE MOTION; BY ISIS
          !--------------------------
          @CURVE(AIRPLANE,'I'//NI,X,Y) 
          TP=TP+DP
        END DO
        GX=-X-30 ! Trajectory target boundary condition on X at T=TIME
        GY=Y-20  !                                         Y at T=TIME
        TERMINATE MOTION
      END

      MODEL MOTION   ! Differential Equations
        D=0.5*RHO*CD*S*V*V
        THEDOT=-G*COS(THETA)/V      ! Equation for THETA(T)
        VDOT=-D/SMASS-G*SIN(THETA)  ! Equation for V(T)
        XDOT=V*COS(THETA)-ABS(VA)   ! Equation for X(T)
        YDOT=V*SIN(THETA)           ! Equation for Y(T)
      END

!===================== GRAPHICS DISPLAY ROUTINES ======================|

      PROCEDURE AXES(NAME,TITLE)
      !----------------------------------------------------------------|
      ! This procedure sets up a profile picture of a jet plane with   |
      ! superimposed axes to illustrate the iterated seat trajectories |
      ! of the two-point boundary-value problem graphically.           |
      !----------------------------------------------------------------|
        CHARACTER*(*) NAME,LABEL,TITLE
        DIMENSION P1(2,6),P2(2,11),TG(2,9)
        !---------- Image data for graph profile of plane -----------
        DATA P1/8.7,0,8.9,.5,7.75,1.5,5,2.2,2.2,3.8,1.8,2.8/
        DATA P2/5,2.2,1.8,2.8,.25,3.1,-0.1,4.0,-21,3.75,-25,3.9,
     &amp;          -26.3,4.75,-29.2,11,-30,12,-32.2,12,-30.3,0/
        DATA TG/-30.6,19.4,-30,19.15,-29.4,19.4,-30.6,20.6,-30,20.85,
     &amp;          -29.4,20.6,-30.6,19.4,-30.85,20,-30.6,20.6/
        !------------------------------------------------------------
        @GRAFIL(NAME,'SUM','IMAGE',0,0) ! Create SUMMARY-stream graph
        @FONT('COMPLEX','STANDARD',0,0) ! Use default char size &amp; color
        @XYPLOT(NAME,'RECT'-30,0,-30,10,0,30,0,10,1.0,0,0,0,0)
        @AXSET(NAME,'LABELS','NONE','NONE','LABELS') 
        @SETUP(NAME,'I1',2,4,0,1) ! 1st Iteration (Blue dashed)
        @SETUP(NAME,'I2',2,3,0,1) ! 2nd Iteration (Green dashed)
        @SETUP(NAME,'I3',2,5,0,1) ! 3rd Iteration (Cyan dashed)
        @SETUP(NAME,'I4',2,1,0,1) ! 4th Iteration (Red dashed)
        @SETUP(NAME,'I5',2,8,0,1) ! 5th Iteration (Magenta dashed)
        @SETUP(NAME,'I6',2,7,0,1) ! 6th Iteration (Orange dashed)
        @SETUP(NAME,'I7',2,9,0,1) ! 7th Iteration (White dashed)
        @SETUP(NAME,'I8',2,6,0,1) ! 8th Iteration (yellow dashed)
        @SETUP(NAME,'I9',2,3,0,1) ! 9th Iteration (Green dashed)
        @SETUP(NAME,'P1',0,4,0,1) ! Plane Outline 1 (Blue solid)
        @SETUP(NAME,'P2',0,4,0,1) ! Plane Outline 2 (Blue solid)
        @SETUP(NAME,'TG',2,6,0,1) ! Target (Yellow dashed)
        @HEAD(NAME,TITLE,50,50,1) ! Chart title (Black) 
        @MESSAGE(NAME,'ALTITUDE',-20.0,30.0,1) ! (Black)
        @NUMBER(NAME,-12.0,30.0,H,4) ! (Blue)
        DO 10 J=1,6
          @CURVE(NAME,'P1',P1(1,J),P1(2,J))
  10    CONTINUE
        DO 20 J=1,11
          @CURVE(NAME,'P2',P2(1,J),P2(2,J))
  20    CONTINUE
        DO 30 J=1,9
          @CURVE(NAME,'TG',TG(1,J),TG(2,J))
  30    CONTINUE
        RETURN
C
        ENTRY DISPLAY(NAME,LABEL)
        @MESSAGE(NAME,5,'SPEED',-20.0,28.0,0)
        @NUMBER(NAME,-12.0,28.0,VA,2) ! (Red)
        @SHOW(NAME,LABEL)
      END

      PROCEDURE SAFE(GNAME)
      !----------------------------------------------------------------|
      ! This procedure sets up the graph of the altitude-velolcity     |
      ! safe ejection profile for the seat-ejection apparatus, which   |
      ! constitutes the desired closed-form solution of the design     |
      ! problem. This would be contrasted with a trial and error       |
      ! scatter diagram, which would be the result of multiple         |
      ! simulation runs with an ordinary simulation language like CSSL.| 
      !----------------------------------------------------------------| 
        CHARACTER*(*) GNAME
        @GRAFIL(GNAME,'SUM','IMAGE',0,0) ! Create SUMMARY-stream graph
        @FONT('COMPLEX','STANDARD',0,0)  ! Default character size & color
        @XYPLOT(GNAME,200,800,200,200,0,50000,0,10000,1.0,0.0)
        @AXNAME(GNAME,'X','SPEED','RIGHT',16,12,2)
        @AXLABS(GNAME,'X','HORI','TICKS','AUTO',1,16,1)
        @AXNAME(GNAME,'Y','ALTITUDE','LEFT',16,12,2)
        @AXLABS(GNAME,'Y','HORI','TICKS','AUTO',-1,1,16,1)
        @SETUP(GNAME,'PP',6,3,3,1)   ! Profile Points (green deltas)
        @SETUP(GNAME,'CR',5,5,0,1) ! Profile Curve (cyan dashed)
        @HEAD(GNAME,'SAFE EJECTION PROFILE',50,50,1) ! Title (black)
        DO 10 J=1,6
          @POINT(GNAME,'PP',VEL(J),ALT(J))
          @CURVE(GNAME,'CR',VEL(J),ALT(J))
   10   CONTINUE
        @DRAW(GNAME,'ALTITUDE-VELOCITY PROFILE GRAPH')  ! no border
      END

      CHARACTER*(*) FUNCTION TOCLABEL(STRING,VALUE)
      !----------------------------------------------------------------|
      ! This function formats a SUMMARY-stream Table of Contents Entry.|
      !----------------------------------------------------------------|
      CHARACTER*(*) STRING
      WRITE(TOCLABEL,10),VALUE
   10 FORMAT(A,'=',F6.0)
      END
</pre>  

<P><B>Problem EJECT</B> - In this program, altitude is used as a parameter 
and the loop (DO 10) is used to solve the problem six times for altitudes 
ranging from 0 to 50,000 feet.  The first line of this loop contains 
three statements which assign the altitude to H, zero the iteration 
counter IT, and compute the character variable PLANE used to name 
a distinct graph object for each cycle of the loop.  Each graph object 
is setup via the command-call to AXES which also plots an image of 
the aircraft profile with the ejection coordinate system.</P>

<P>Safe ejection is defined, somewhat simplistically, by a target in 
space 8 feet above the rudder of the aircraft.  If a trajectory passes 
through this point with minimum time from ejection, then this defines 
the maximum aircraft speed for safe ejection.  Any higher speed will 
result in a trajectory which passes under this point.  Consequently, 
the profile of safe ejection can be determined exactly for this model, 
by solving a two point boundary-value problem for each altitude, computing 
the aircraft speed VA and the elapsed time from ejection TIME to match 
the boundary conditions on X and Y defining the target point above 
the rudder.  This problem is posed by the FIND statement which iteratively 
shoots trajectories using Newton's method to converge on VA and TIME 
to match the target constraints GX and GY.</P>

<P>The subsequent command-call to DISPLAY (an entry point in AXES) labels 
the aircraft speed in the graph, and produces the graph for the particular 
cycle of the loop.  This is followed by accumulation of the computed 
maximum speed in the array VEL to be used to generate the profile 
curve after exiting the loop by the command-call to the SAFE procedure.</P>

<P><B>Model SEAT</B> - This model controls the trajectory simulation 
for the pilot seat.  It first computes the initial conditions of the 
trajectory from the aircraft speed parameterVA and relates the integration 
step size DT to one twentieth of the unknown duration TIME of the 
trajectory, then uses @POINT or @CURVE to plot the initial point on 
the trajectory identified by 'I' concatenated with the character conversion 
of the iteration number.</P>

<P>The INITIATE statement sets up the integration of the four simultaneous 
differential equations, contained in model MOTION, defining TP as 
the time when the trajectory will be interrupted for plotting.  The 
subsequent DO WHILE loop causes integration to be carried out and 
plotting of the trajectory points via @CURVE.</P>

<P>Following the loop, the trajectory iteration is complete, and the 
constraints GX and GY are computed.  This is followed by the TERMINATE 
statement which returns the internal integration arrays to free storage.</P>

<P>Because this program unit is a <I>model</I>, its assignment statements 
are overloaded for differentiation and partial derivatives of every 
real variable computed will be generated with respect to the variables 
VA and TIME.  Of course this also includes the model MOTION, and the 
integation solver ISIS.  This enables differentiation to be propagated 
though the trajectory, so that the gradients of GX and GY, representing 
the boundary conditions, are computed with respect to the iterative 
unknowns VA and TIME.</P>

<P><B>Procedure AXES</B> - This procedure contains most of the graphics 
operations necessary to synthesize the six profile graphs given in 
figures 8-3 to 8-8.  AXES creates the graph object with the command 
@GRAPH.  It establishes the absolute character size at 0.2 inches 
for printing on a 300 DPI laser printer, and defines a 5 inch by 4 
inch frame in the lower-left corner of the printer's raster.  The 
plotting window of the graph is then generated via the @WINDOW command.  This 
establishes the scaling for the subsequent functions to be plotted.</P>

<P>The @SETUP group creates curves in the database corresponding to each 
trajectory iteration and also the curves 'P1', 'P2', and 'TG' of the 
aircraft and target which are generated by the subsequent loops.</P>

<P><B>Procedure SAFE</B> - This procedure synthesizes and produces the 
SAFE EJECTION PROFILE curve which is the final result of the program. 
This curve is give in Figure 8-9.  All point above and left of the 
curve are considered safe.<P>FIG 8-3, 8-4, 8-5, ... 8-9 eject profiles<br><BR>

<B><U>   Application Problem 8-3: Chemical Parameters Estimation</U></B><BR>

<p>This program is a variation of Application Problem 6-2 to illustrate 
iterative trajectory optimization fitting via graphics.  It produces 
a graphics illustration of each trajectory simulation corresponding 
to each iteration of the optimization problem.</P>

<P>The graphics additions are introduced in model CURFIT with the AXES 
command-call which sets up graphics objects for each iteration.  The 
integrated trajectories of the four chemical concentrations are plotted 
via the CURVES command-call.  The measured points of concentrations 
A and C are plotted via the MEASURED command call.  Finally, the iteration 
graph is produced via the @SHOW command.</P>
<P><pre>

 GLOBAL ALL     !germano 1/16
      PROBLEM CHEMPARE ! Chemical Kinetics Parameter Estimation      
        DIMENSION TM(6),CM(6),AM(6)
        DATA TM/10,20,30,40,50,60/  ! Time points for measurements
        DATA CM/0.419,0.563,0.629,0.666,0.689,0.708/ ! C measurements
        DATA AM/0.483,0.281,0.191,0.134,0.097,0.065/ ! A measurements
        DATA NM,A0,B0,C0,D0,DT/6,1.0,1.03,0.0,0.0,2.0/ ! Initial Cond.       
        DATA B1,B2/0.015,0.015/ ! Optimization step bounds
        P1=0.01 : P2=0.05 ! Parameter starting guesses
        INITIATE ATHENA; FOR REACTION;
     &amp;    EQUATIONS DADT/A,DBDT/B,DCDT/C,DDDT/D;  
     &amp;    OF T; STEP DT; TO TF
        FIND P1,P2; IN CURFIT;
     &amp;    BY HERA(SET); WITH BOUNDS B1,B2; TO MINIMIZE ERROR
      END

      MODEL CURFIT
        CHARFUN FCSINT*2
        CHARACTER*2 NI
        DATA IT/0/ : NI=FCSINT(IT)
        @AXES('ITER'//NI,'ITERATION '//NI)
        A=A0 : B=B0 : C=C0 : D=D0 : T=0 : TF=0
        ERROR=0 : I=1
        DO WHILE (I.LE.NM)
          TF=TF+DT
          INTEGRATE REACTION; BY ATHENA
          @CURVES('ITER'//NI)
          IF(TF.EQ.TM(I)) THEN
            ERROR=ERROR+(AM(I)-A)**2+(CM(I)-C)**2   ! Cumulative error
            @MEASURED('ITER'//NI,AM(I),CM(I),TM(I)) ! Plot measurement
            I=I+1
          ENDIF
        END DO
        @SHOW('ITER'//NI,0)  ! Show graph for this iteration
        IT=IT+1
      END
 
      MODEL REACTION ! Rates of reaction differential equations
        DCDT=P1*A*B
        DADT=-(DCDT+(.01+P2)*A
        DBDT=-(DCDT+.05*B*D)
        DDDT=DBDT-DADT
      END

      CONTROLLER SET(HERA)
        DELTA=1E-2
        DETAIL=1
        ADJUST=2
      END

      PROCEDURE AXES(GNAME,TITLE)
        CHARACTER*(*) GNAME,TITLE
        @GRAFIL(GNAME,'PNG','IMAGE',0,0) ! Generate PNG image file of default size
        @FONT(GNAME,'COMPLEX','STANDARD',0,10)  ! Use default character size and color   
        @AXNAME(GNAME,'X','TIME (MINUTES)','CENT',30,36,10)  
        @AXNAME(GNAME,'Y','CONCENTRATION','CENT',30,36,10)   
      @XYPLOT(GNAME,'RECT',0.0,60.0,0.0,10.0,0,1.0,0.0,0.1,1.0,0,0,0,0)
        @SETUP(GNAME,'AM',0,2,1,-1) ! A Measured (Red boxes)
        @SETUP(GNAME,'CM',0,8,3,-1) ! C Measured (Mga deltas)
        @SETUP(GNAME,'A ',0,2,0,1) ! A Curve (Red)
        @SETUP(GNAME,'C ',2,8,0,1) ! C Curve (Magenta)
        @SETUP(GNAME,'B ',3,3,0,1) ! B Curve (Green)
        @SETUP(GNAME,'D ',4,7,0,1) ! D Curve (Orange)
        @HEAD(GNAME,'CHEMICAL PARAMETERS ESTIMATION',50,50,10) ! Chart Title (FORE)
        @HEAD(GNAME,TITLE,50,100,10)
        @MESSAGE(GNAME,'P1= ',20.0,.9,4) ! (Blue)
        @NUMBER(GNAME,P1,4,999.,999.,10,0,2) ! (Red)
        @MESSAGE(GNAME,'P2= ',20.0,.85,4) ! (Blue)
        @NUMBER(GNAME,P2,4,999.,999.,10,0,2) ! (Red)
      END

      MODEL CURVES(GNAME)  ! Generate points on integral curves
        CHARACTER*(*) GNAME
        @CURVE(GNAME,'A ',T,A)
        @CURVE(GNAME,'C ',T,C)
        @CURVE(GNAME,'B ',T,B)
        @CURVE(GNAME,'D ',T,D)
      END

      MODEL MEASURED(GNAME,AP,CP,TP) ! Generate measured points
        CHARACTER*(*) GNAME
        @POINT(GNAME,'AM',TP,AP)
        @POINT(GNAME,'CM',TP,CP)
      END

</pre></P>

<P>The graphical results of the iterations are shown in Figures 8-10 
to 8-16, depicting the sequential approximation process of optimization. 
The trajectories of the chemical concentrations, predicted by the 
differential equations, are the smooth curves.  On a color monitor 
screen, these would appear in the labeled colors.  However, in the 
black & white laser printer image, specific dashed patterns are assigned 
to each color.</P>

<P>The measured data values of A and C are also color coded to indicate 
correspondence between the curves and the data.  As the iterations 
proceed, these curves successively approach coincidence with the data 
values until convergence in iteration six (Figure 8-16) when they 
are matched in a least-squares sense.</P>

<P>This problem demonstrates the power of optimization for phenomenological 
curve fitting (process identification).  Because of the coupling of 
the differential equations, this provides the means of "measuring 
the unmeasurable" as exemplified by the remaining curves B and D for 
which no data existed.  Moreover, the whole process is an indirect 
way of "measuring" the parameters P1 and P2 that could conceivably 
be programmed into the instrument that acquires the measurement samples.</P>
<P>

<img alt="Fig 8-10" src="graphs/chempare/dislin.png" class="style17"><br>
Figure 8-11 Chemical parameters initial guess iteration<br><br>

<img alt="Fig 8-11" height="598" src="graphs/chempare/dislin_1.png" width="853" class="style17"><br>
Figure 8-12 First optimization iteration<br><br>

<img alt="Fig 8-12" height="603" src="graphs/chempare/dislin_2.png" width="853" class="style17"><br>
Figure 8-12 Second optimization iteration<br><br>

<img alt="Fig 8-13" height="598" src="graphs/chempare/dislin_3.png" width="853" class="style17"><br>
Figure 8-13 Third optimization iteration<br><br>

<img alt="Fig 8-14" height="603" src="graphs/chempare/dislin_4.png" width="853" class="style17"><br>
Figure 8-14 Fourth optimization iteration<br><br>

<img alt="Fig 8-15" height="608" src="graphs/chempare/dislin_5.png" width="704" class="style17"><br>
Figure 8-15 Fifth optimization iteration<br><br>

<img alt="FIG 8-16" height="603" src="graphs/chempare/dislin_6.png" width="853" class="style17"><br>
Figure 8-16. Sixth (Converged) optimization iteration<br><br>

<H2>Contour Plotting Applications</H2>

<P>The following applications illustrate the synthesis and production 
of contour graphs.  This type of graph is a two-dimensional representation 
of a three-dimensional function by using contour curves to show the 
intersection of different level planes with the function's surface, 
thereby depicting the three-dimensional shape of the function.<br><BR>

<B><U>   Application 8-4: Constrained Optimization Solver Comparison</U></B><BR>

In this application, a two dimensional function is optimized subject 
to a set of inequality constraints in order to demonstrate the different 
search patterns of constrained optimization solvers using the same 
initial starting point.  The objective function resembles a rolling 
hillside with a nearby saddle point.  A set of constraint functions 
are superimposed upon it to enclose a feasible region resembling and 
oddly shaped corral containing the saddle point, with a parabolic 
fence guarding a narrow slope up the hillside toward the highest point 
on the northeast corner.  The output of eight variations of this program 
are illustrated in Figures 8-17 to 8-25, showing the different search 
patterns of the constrained optimizers THOR, ZEUS, JOVE, and JUPITER, 
in two different levels of difficulty. The initial variation of the 
program is given below.</P>
<pre>
 PROBLEM HB1TG(10000,2000,2000)
        COMMON/PRIN/X,Y,G(5),F
        @CONGRAF    ! Generate Contour &amp; Constraint Graph
        X=90 : Y=20 : BX=5 : BY=10
        FIND X,Y; IN HB; BY THOR(SET); WITH BOUNDS BX,BY;
     *     HOLDING G; TO MAXIMIZE F
        @SHOW('HBF',0)    ! Display Graph
      END

      CONTROLLER SET(THOR)
        CONVERGE=2
        DETAIL=1
      END

      MODEL HB
        COMMON/PRIN/X,Y,G(5),F
        G(1)=X*Y-700 : G(2)=75-X : G(3)=65-Y : 
        G(4)=Y-X*X/125 : G(5)=(Y-50)**2-5*X+275
        F1 = 75.1963666677 - 3.8112755343*X + 0.1269366345*X*X
     *      - 0.0020567665*X**3
        F2 = 1.0345E-5*X**4 - 6.8306567613*Y + 0.0302344793*X*Y
     *      - 0.0012813448*X*X*Y
        F3 = 3.52559E-5*X**3*Y - 2.266E-7*X**4*Y + 0.2564581253*Y*Y
     *      - 3.460403E-3*Y**3
        F4 = 1.35139E-5*Y**4 - 28.1064434908/(Y+1) 
     *      - 5.2375E-6*X*X*Y*Y
        F5 = -6.3E-9*X**3*Y*Y + 7E-10*X**3*Y**3 + 3.405462E-4*X*Y*Y
        F6 = -1.6638E-6*X*Y**3 - 2.8673112392*EXP(5E-4*X*Y)
        F=F1+F2+F3+F4+F5+F6
        @CURVE('HBF','SR',X,Y)   ! Plot point on search trace
      END

      SUBROUTINE CONGRAF
        IMPLICIT REAL*8 (A-H,O-Z)
        DIMENSION CONS(9),LABL(9),LTYP(9),KLR(9)
        DATA X1,X2,Y1,Y2/-10,110,-10,110/
        DATA XA,XB,YA,YB/0,100,0,100/
        DATA CONS/-80,-40,0,10,20,30,40,50,55/
        DATA LABL/1,0,1,0,1,0,1,0,1/
        DATA LTYP/0,2,0,2,0,2,0,2,0/
        DATA KLR /3,3,3,3,3,3,3,3,3/
        EXTERNAL HBCON
        N=101 : XO=X1 : YO=Y1
        @GRAFIL('HBF','PNG','IMAGE',0,0) ! Generate PNG image file of default size
        @FONT('HBF','COMPLEX','STANDARD',0,0)  ! Use default character size and color 
        @AXSET('HBF','NONE','NONE','NONE','NONE') ! Suppress axis plotting
        @XYPLOT('HBF','RECT',X1,X2,X1,X2-X1,Y1,Y2,Y1,Y2-Y1,1.0,0,0,0,0)
        @MESH('HBF','CS',XA,XB,YA,YB,N,N,HBCON)
        @CONTOUR('HBF','CS',CONS,LABL,KLR,LTYP,9)
        @HEAD('HBF','HILLSIDE CORRAL',50,40,10)
        @HEAD('HBF','SOLVER THOR',50,100,10)
        @SETUP('HBF','G1',2,7,0,1) ! (orange dashed)
        DO 10 I=10,50
            X=I : Y=700/X
            @CURVE('HBF','G1',X,Y)
 10     CONTINUE
        @SETUP('HBF','G2',2,7,0,1) ! (orange dashed)
        @CURVE('HBF','G2',75,70)
        @CURVE('HBF','G2',75,55)
        @SETUP('HBF','G3',2,7,0,1) ! (orange dashed)
        @CURVE('HBF','G3',5,65)
        @CURVE('HBF','G3',80,65)
        @SETUP('HBF','G4',2,7,0,1) ! (orange dashed)
        DO 20 I=40,75
            X=I : Y=X*X/125
            @CURVE('HBF','G4',X,Y)
 20     CONTINUE
        @SETUP('HBF','G5',2,7,0,1) ! (orange dashed)
        DO 30 I=80,55,-1
            X=I : Y=SQRT(5*X-275)+50
            @CURVE('HBF','G5',X,Y)
 30     CONTINUE
        DO 40 I=55,80
            X=I : Y=-SQRT(5*X-275)+50
            @CURVE('HBF','G5',X,Y)
 40     CONTINUE
        @SETUP('HBF','SR',1,4,-5,1) ! (blue dotted with cross points)
      END

      FUNCTION HBCON(X,Y)
        F1 = 75.1963666677 - 3.8112755343*X + 0.1269366345*X*X
     *      - 0.0020567665*X**3
        F2 = 1.0345E-5*X**4 - 6.8306567613*Y + 0.0302344793*X*Y
     *      - 0.0012813448*X*X*Y
        F3 = 3.52559E-5*X**3*Y - 2.266E-7*X**4*Y + 0.2564581253*Y*Y
     *      - 3.460403E-3*Y**3
        F4 = 1.35139E-5*Y**4 - 28.1064434908/(Y+1) 
     *      - 5.2375E-6*X*X*Y*Y
        F5 = -6.3E-9*X**3*Y*Y + 7E-10*X**3*Y**3 + 3.405462E-4*X*Y*Y
        F6 = -1.6638E-6*X*Y**3 - 2.8673112392*EXP(5E-4*X*Y)
        HBCON=F1+F2+F3+F4+F5+F6
      END
</pre></P>



<P>In the next three variations of this program, the FIND statements 
were changed in the following sequence:<br><BR>

 &nbsp;&nbsp;&nbsp;

 FIND X,Y; IN HB; BY ZEUS; HOLDING G; TO MAXIMIZE F<BR>

 &nbsp;&nbsp;&nbsp;

 FIND X,Y; IN HB; BY JOVE; HOLDING G; TO MAXIMIZE F<BR>

 &nbsp;&nbsp;&nbsp;

 FIND X,Y; IN HB; BY JUPITER; HOLDING G; TO MAXIMIZE F<br><BR>

The final four variations of the program added the following constraint<br><BR>

 &nbsp;&nbsp;&nbsp;

 G(6) = X-54<br><BR>

as a north-south fence leaving a narrow gap in the feasible region 
for the solvers to deal with.</P>


<H3>Graphical Operations</H3>

<P>In the PROBLEM procedure, the command-call to procedure CONGRAF serves 
to setup graph synthesis, and the final command @SHOW serves to produce 
the graph image from the accumulated graph object.</P>

<P><B>Procedure CONGRAF </B>- The steps required to setup contour graph 
synthesis are as follows:
<UL>
<LI>@GRAPH creates the graph object 'HBF' in the database;
</LI>
<LI>@CHRSIZE sets the character size for printing at 0.05 inches;
</LI>
<LI>@FRAME defines a 5-inch by 4-inch print frame for the graph 
in the lower left corner of the page;
</LI>
<LI>@CONTDEF defines the contour function 'CS' having green 
contours and light cyan marker labels on the labeled contours;
</LI>
<LI>@WINDOW creates and sets the scale factors of the plotting 
window;
</LI>
<LI>@MESH generates a table of the contour function by calling 
the external function HBCON.<p>Note that HBCON is formally the same as the 
model HB. However, HB cannot be used because it is not programmed as a function, 
and computes REAL*8 values. HBCON must be a REAL*4 function for compatibility 
with the graphics library.</p>
</LI>
<LI>@CONTOUR defines nine contours in array CONS with alternating 
labels as dictated by integer array LABL;
</LI>
<LI>Titles are placed on the graph using the @LABEL command;
</LI>
<LI>@SETUP is used to create the first yellow constraint curve 
'G1' and the curve is generated by the DO loop in which the connected 
points are plotted;
</LI>
<LI>@SETUP creates the linear constraint 'G2' and it is generated 
by two @CURVE commands;
</LI>
<LI>Constraint 'G3' is created similarly;
</LI>
<LI>Constraints 'G4', 'G5', and 'G6' are created via @SETUP 
and the loops on statements 20, 30, and 40;
</LI>
<LI>Finally, the search path 'SR' is defined by @SETUP using 
-1 to denote the default '+' symbol to be used for plotting.
</LI>
</ul>
<P><B>Search Path Plotting -</B> The actual search path of the optimizer 
is plotted via the @CURVE command appearing at the end of model HB.</P>

<p>
<B>Optimizer Comparison Results-</B>The graphical comparisons of 
the paths of the optimizers for the simpler problem are shown in Figures 
8-17 to 8-20.  All solvers were equally capable of solving this version 
of the problem.  Note the conservative stepping of THOR, an LP-based 
method, and ZEUS, A first-order sequential unconstrained minimization 
(SUM), as compared to the more robust solvers JOVE and JUPITER.
</p>

<P>In the more difficult version of the problem, having the narrow gap 
(Figures 8-21 to 8-25), THOR converged prematurely at the entrance 
to the gap, whereas the other three solvers had no difficulty finding 
the same maximum as before.<BR>
</P>
<p><img height="603" src="graphs/hb1tg/dislin.png" width="853" class="style17"><br>
Figure 8-17 THOR search path for lesser difficulty</P>
<p><img height="603" src="graphs/hb1tg/dislin_1.png" width="853" class="style17"><br>
Figure 8-18 ZEUS search path for lesser difficulty [fix]&nbsp;&nbsp;&nbsp; 
[RERUN, get rest of figures]</P>
<p><img height="603" src="graphs/hb1tg/dislinX.png" width="853" class="style17"><br>
Figure 8-19 JOVE search path for lesser difficulty</P>
<p><img height="603" src="graphs/hb1tg/dislinX.png" width="853" class="style17"><br>
Figure 8-20 JUPITER search path for lesser difficulty</P>
<p><img height="603" src="graphs/hb1tg/dislinX.png" width="853" class="style17"><br>
Figure 8-21 THOR search path for greater difficulty</P>
<p><img height="603" src="graphs/hb1tg/dislinX.png" width="853" class="style17"><br>
Figure 8-22 ZEUS search path for greater difficulty</P>
<p><img height="603" src="graphs/hb1tg/dislinX.png" width="853" class="style17"><br>
Figure 8-23 JOVE search path for greater difficulty</P>
<p><img height="603" src="graphs/hb1tg/dislinX.png" width="853" class="style17"><br>
Figure 8-24 JUPITER  search path for greater difficulty</P>

<B><U>   Application 8-5: Unconstrained Optimization of Multiple Extrema</U></B><BR>

<p>This application is a study of the use of the unconstrained optimization 
solver HERA with a function having multiple extrema.  It is a further 
illustration of the use of contour graphics to gain insight into how 
solvers behave.  The particular function under study has a single 
maximum, four minima, and four saddle points in the region of the 
origin.  Since HERA applies a second-order Newton method that can 
discriminate the type of extrema, the aim of the program is to observe 
a sequence of paths from different starting points involving a search 
for any extremum in the manner of a standard Newton method, followed 
by a search for a maximum, followed by a search for a minimum.  This 
is achieved via the following program:</P>

<DIV>
<pre>
  PROBLEM MULTEXTR (10000,2000,2000) ! Multiple Extrema
        COMMON/PRIN/X,Y,Q,F,F1,CONG
        DIMENSION XS(4),YS(4)
        DATA XS/-1,-2,1,2/
        DATA YS/ 2,-3,3,-3/
        DO 10 I=1,4
          @CONGRAF    ! Generate Contour Graph

          X=XS(I): Y=YS(I)
          BX=1 : BY=1
          @POINT('FUNC','PT',X,Y)  
          FIND X; IN FUNC; BY HERA; WITH BOUNDS BX; TO EXTREMIZE F

          X=X*.999: Y=Y*.999
          @POINT('FUNC','PT',X,Y)  
          FIND X; IN FUNC; BY HERA; WITH BOUNDS BX; TO MAXIMIZE F
          @POINT('FUNC','PT',X,Y)   
         
          FIND X; IN FUNC; BY HERA; WITH BOUNDS BX; TO MINIMIZE F
          @POINT('FUNC','PT',X,Y)
          @SHOW('FUNC')    ! Display Graph
          @CLEAR('FUNC')
 10     CONTINUE
      END

      MODEL FUNC
        COMMON/PRIN/X,Y,Q,F,F1,CONG
        Q=X
        FIND Y; IN FUN2; BY JUPITER; REPORTING Q; TO MINIMIZE F1
        F=(X*X+Y-11)**2+(X+Y*Y-7)**2
        PARDPRINT F,Q
        CONG=F-100
      END    

      MODEL FUN2
        COMMON/PRIN/X,Y,Q,F,F1,CONG
        F1=(Q*Q+Y-11)**2+(Q+Q*Y-7)**2
        PARDPRINT F1        
        @CURVE('FUNC','SR',X,Y)   ! Plot point on search trace
      END

      PROCEDURE CONGRAF ! Contour Graph Generator
        DIMENSION CONS(9),LABL(9)
        DATA X1,X2,Y1,Y2/-6.5,6,-6,6/
        DATA XA,XB,YA,YB/-5.5,5.5,-5,5/
        DATA CONS/1,25,50,75,100,125,150,175,180/
        DATA LABL/1,0,0,0,0,0,0,0,1/
        EXTERNAL FCON			      !THINK ABOUT THIS
        N=101 : XO=XA : YO=YA

        @GRAFIL('FUNC','PNG','IMAGE',0,0)     ! CHECK IMAGE meaning
        @FONT('FUNC','COMPLEX','STANDARD',0,0) !set font
        @CONTDEF('FUNC','CS',2,2,3,1)
        @XYPLOT('FUNC','RECT',-5.0,5.5,-4.5,0.5,05.0,5.5,-4.0,0.5)
        @XAXIS('FUNC',XA,XB,1,0,1,1)
        @YAXIS('FUNC',YA,YB,1,0,1,1)

        @MESH('FUNC','CS',XA,XB,YA,YB,N,N,FCON)
        @CONTOUR('FUNC','CS',1,CONS,LABL,9,2)
        @SETUP('FUNC','PT',0,14,ICHAR('*'),14)
        @SETUP('FUNC','SR',0,12,-1,4)
      END

      FUNCTION FCON(X,Y)  ! Contour graph function
        FCON=(X*X+Y-11)**2+(X+Y*Y-7)**2
      END
</PRE>
</DIV>



<P>The program contains a sequence of three FIND statements that extremize, 
maximize, and minimize the same function in sequence, marking the 
starting point and each critical point with an asterisk.</P>

<P>The graphics operations are similar to the previous application except 
that axes are drawn in this case.</P>

<P>The results for the given starting points yield similar behavior.  From 
the first two starting points at (-1,3) and (1,3), the first FIND 
statement converges at the saddle point at the top (Figures 8-25 and 
8-26).  Following this statement the X and Y values are multiplied 
by .999 to nudge the starting point slightly uphill in the direction 
of the origin so that the second FIND will seek the maximum below 
the origin.  From this maximum, the last FIND statement traced search 
paths that were essentially identical in all of the runs, arriving 
at the minimum in the upper right corner.</P>

<P>The second two starting points (-2,-3) and (2,-3) first converged 
to the saddle point just below the maximum(Figures 8-27 and 8-28).  Then 
the second FIND achieved the maximum in a single step, and the third 
FIND repeated the path taken before.</P>
<P>FIGS 8-26 TO 8-28; HERA EXT-MAX-MIN&nbsp; -1,3&nbsp;&nbsp; 1,3&nbsp;&nbsp; 
-2,-2&nbsp;&nbsp; 2,3</P>


<h1> 8.3 Preset Symbolic Parameters</h1>
<div >
<p >The following preset integer parameters are available to 
denote line types, plot symbols, and colors.</p>
<h2 >8.3.1 Line Type Parameters</h2>
<p >LN_SOL = 0 : Solid lines ____________</p>
<p >LN_DOT = 1 : Dotted lines ...........................</p>
<p >LN_DASH = 2 : Dashed lines ---------------------</p>
<p >LN_CHNDSH = 3 : Chain-Dash lines _._._._._._._._.</p>
<p >LN_CHNDOT = 4 : Chain-Dot lines -.-.-.-.-.-.-.-.-.-.-.-.</p>
<p >LN_DASHM = 5 : Medium Dash _ _ _ _ _ _ _ _ _</p>
<p >LN_DOTL = 6 : Long Dots . . . . . . . . . . . . . . </p>
<p >LN_DASHL = 7 : Long Dashes __ __ __ __ __</p>
<p ><br><br></p>
<h2 >8.3.2 Symbol Type Parameters</h2>
<p >SY_BOX = 0 : Box symbol
&#9633;</p>
<p >SY_HEX = 1 : Hexagon 
&#9788;</p>
<p >SY_DELTA = 2 : Delta 
&#916;</p>
<p >SY_PLUS = 3 : Plus +</p>
<p >SY_X = 4 : X x</p>
<p >SY_DIAM = 5 : Diamond 
&#9674;</p>
<p >SY_DEL = 6 : Del
-</p>
<p >SY_XBOX = 7 : Xbox
&#9746;</p>
<p >SY_XPLUS = 8 : Xplus
&#10035;</p>
<p >SY_XDIAM = 9 : 
CrossInDiamond</p>
<p >SY_HEXPLUS = 10 : 
CrossInHexagon</p>
<p >SY_DELDELTA = 11 : 
DelsOverDeltas</p>
<p >SY_BOXPLUS = 12 : 
CrossInBox</p>
<p >SY_XHEX = 13 : XinHexagon</p>
<p >SY_BOXDELTA = 14 : 
DeltaInBox</p>
<p >SY_CIRCL = 15 : Circle</p>
<p >SY_SOLBOX =16 : SolidBox</p>
<p >SY_SOLHEX = 17 : 
SolidHexagon</p>
<p >SY_SOLDELTA = 18 : 
SolidDelta</p>
<p >SY_SOLDIAM = 19 : 
SolidDiamond</p>
<p >SY_SOLDEL = 20 : SolidDel</p>
<p >SY_SOLCIRC = 21 : 
SolidCircle</p>
<h2 >8.3.3 Color Parameters</h2>
<p><br><br></p>
<p >CL_BLACK = 1 : Black</p>
<p >CL_RED = 2 : Red</p>
<p >CL_GREEN = 3 : Green</p>
<p >CL_BLUE = 4 : Blue</p>
<p >CL_CYAN = 5 : Cyan</p>
<p >CL_YELLOW = 6 : Yellow</p>
<p >CL_ORANGE = 7 : Orange</p>
<p >CL_MAGENTA = 8 : Magenta</p>
<p >CL_WHITE = 9 : White</p>
<p >CL_FORE = 10 : Foreground color</p>
</div>

</BODY></HTML>